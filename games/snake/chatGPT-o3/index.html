<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="/AIGameGallery/assets/common.css">
  <title>Snake Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {font-family: system-ui, sans-serif;}
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background: #111;
      color: #eee;
    }
    canvas {
      background: #222;
      box-shadow: 0 0 10px rgba(0, 0, 0, .5);
      border-radius: 8px;
      outline: none;
    }
    #score {margin-top: 1rem; font-size: 1.25rem;}
    button {
      margin-top: 1rem;
      padding: .5rem 1rem;
      font-size: 1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #28a745;
      color: #fff;
    }
    button:hover {filter: brightness(1.1);}
  </style>
</head>
<script>
  /* optional per-page notes */
  window.AI_GAME_NOTES = `
    <strong>About this Snake build</strong><br>
    • Model: ChatGPT o3<br>
    • First pass, minimal refactor<br>
    • Uses wrap-around instead of walls.
  `;
</script>
<script src="/AIGameGallery/assets/common.js"></script>
<body>
  <canvas id="game" width="400" height="400" tabindex="0"></canvas>
  <div id="score">Score: 0</div>
  <button id="restart" hidden>Restart</button>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const gridSize = 20; // cell size in px
      const tileCount = canvas.width / gridSize;

      let snake;
      let food;
      let dx, dy;
      let score;
      let gameInterval;
      const speed = 100; // ms per frame

      const restartBtn = document.getElementById('restart');
      const scoreEl = document.getElementById('score');

      function init() {
        console.clear();
        console.log('--- Game init ---');
        snake = [{ x: 10, y: 10 }];
        dx = 1;   // start moving to the right so no immediate self‑collision
        dy = 0;
        console.log('Snake initialized', JSON.stringify(snake));
        placeFood();
        score = 0;
        scoreEl.textContent = 'Score: 0';
        restartBtn.hidden = true;

        clearInterval(gameInterval);
        gameInterval = setInterval(loop, speed);
      }

      function placeFood() {
        food = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount),
        };
        // ensure food doesn't spawn on the snake
        if (snake.some((seg) => seg.x === food.x && seg.y === food.y)) {
          placeFood();
          return;
        }
        console.log('Placed food at', JSON.stringify(food));
      }

      function loop() {
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        console.log('Loop tick', { head, dx, dy, snakeLength: snake.length });

        // wrap around the edges
        head.x = (head.x + tileCount) % tileCount;
        head.y = (head.y + tileCount) % tileCount;

        // check collision with self (skip index 0 because that's the previous head)
        if (snake.slice(1).some((seg) => seg.x === head.x && seg.y === head.y)) {
          console.warn('Self-collision detected at', JSON.stringify(head));
          gameOver();
          return;
        }

        snake.unshift(head);

        // check food collision
        if (head.x === food.x && head.y === food.y) {
          score++;
          console.log('Ate food at', JSON.stringify(head), 'New score', score);
          scoreEl.textContent = 'Score: ' + score;
          placeFood();
        } else {
          snake.pop();
        }

        draw();
      }

      function draw() {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // draw food
        ctx.fillStyle = '#e83e8c';
        ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

        // draw snake
        ctx.fillStyle = '#17a2b8';
        snake.forEach((seg, index) => {
          ctx.fillRect(seg.x * gridSize, seg.y * gridSize, gridSize, gridSize);
          // add eyes to the head for fun
          if (index === 0) {
            ctx.fillStyle = '#fff';
            const eyeSize = gridSize / 5;
            ctx.fillRect(seg.x * gridSize + eyeSize, seg.y * gridSize + eyeSize, eyeSize, eyeSize);
            ctx.fillRect(seg.x * gridSize + 3 * eyeSize, seg.y * gridSize + eyeSize, eyeSize, eyeSize);
            ctx.fillStyle = '#17a2b8';
          }
        });
      }

      function gameOver() {
        clearInterval(gameInterval);
        console.error('--- Game Over ---', 'Final score:', score);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '32px system-ui';
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
        restartBtn.hidden = false;
      }

      function changeDirection(event) {
        console.log('Key pressed', event.key);
        switch (event.key) {
          case 'ArrowUp':
          case 'w':
          case 'W':
            if (dy === 1) break;
            dx = 0;
            dy = -1;
            break;
          case 'ArrowDown':
          case 's':
          case 'S':
            if (dy === -1) break;
            dx = 0;
            dy = 1;
            break;
          case 'ArrowLeft':
          case 'a':
          case 'A':
            if (dx === 1) break;
            dx = -1;
            dy = 0;
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            if (dx === -1) break;
            dx = 1;
            dy = 0;
            break;
        }
        console.log('New direction', { dx, dy });
      }

      restartBtn.addEventListener('click', init);
      document.addEventListener('keydown', changeDirection);
      canvas.focus();
      init();
    })();
  </script>
</body>
</html>
