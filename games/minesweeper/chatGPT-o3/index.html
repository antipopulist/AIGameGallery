<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minesweeper â€“ VanillaÂ JS</title>
  <style>
    :root {
      --cell-size: 32px;
      --font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      font-family: var(--font);
      background:#111;
      color:#eee;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:1rem;
      margin:0;
      padding:2rem 0;
    }
    #game {
      display:grid;
      grid-template-columns:repeat(var(--cols), var(--cell-size));
      grid-template-rows:repeat(var(--rows), var(--cell-size));
      border:4px solid #666;
      box-shadow:0 0 10px #0008;
      user-select:none;
    }

    .cell {
      width:var(--cell-size);
      height:var(--cell-size);
      display:flex;
      justify-content:center;
      align-items:center;
      background:#444;
      border:1px solid #333;
      cursor:pointer;
      font-weight:bold;
      font-size:1rem;
    }
    .cell.revealed {
      background:#bbb;
      border:1px solid #999;
      cursor:default;
    }
    .cell.flagged {
      background:#e74c3c;
      color:#fff;
    }
    .cell.mine {
      background:#c0392b;
    }
    #status {
      font-size:1.25rem;
    }
  </style>
</head>
<body>
  <h1>Minesweeper</h1>
  <div id="game"></div>
  <div id="status"></div>
  <script>
    // Config
    const ROWS = 10;
    const COLS = 10;
    const MINES = 15;

    // State
    let board = [];
    let firstClick = true;
    let flagsLeft = MINES;
    let cellsToReveal = ROWS * COLS - MINES;
    const status = document.getElementById('status');

    // Helpers
    const inBounds = (r, c) => r >= 0 && r < ROWS && c >= 0 && c < COLS;
    const getNeighbors = (r, c) => {
      const deltas = [-1, 0, 1];
      const list = [];
      deltas.forEach(dr => deltas.forEach(dc => {
        if (dr || dc) {
          const nr = r + dr, nc = c + dc;
          if (inBounds(nr, nc)) list.push([nr, nc]);
        }
      }));
      return list;
    };

    function plantMines(safeR, safeC) {
      let placed = 0;
      while (placed < MINES) {
        const r = Math.floor(Math.random() * ROWS);
        const c = Math.floor(Math.random() * COLS);
        if (board[r][c].mine || (Math.abs(r - safeR) <= 1 && Math.abs(c - safeC) <= 1)) continue; // don't plant near first click
        board[r][c].mine = true;
        placed++;
      }
      // Compute numbers
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c].mine) continue;
          const count = getNeighbors(r, c).filter(([nr, nc]) => board[nr][nc].mine).length;
          board[r][c].number = count;
        }
      }
    }

    function reveal(r, c) {
      const cell = board[r][c];
      if (cell.revealed || cell.flagged) return;
      cell.revealed = true;
      cell.el.classList.add('revealed');
      if (cell.mine) {
        cell.el.textContent = 'ðŸ’£';
        gameOver(false);
        return;
      }
      if (cell.number) {
        cell.el.textContent = cell.number;
        cell.el.style.color = [null,'blue','green','red','darkblue','maroon','turquoise','black','gray'][cell.number];
      }
      cellsToReveal--;
      if (cellsToReveal === 0) gameOver(true);
      if (cell.number === 0) {
        getNeighbors(r, c).forEach(([nr, nc]) => reveal(nr, nc));
      }
    }

    function toggleFlag(r, c) {
      const cell = board[r][c];
      if (cell.revealed) return;
      if (!cell.flagged && flagsLeft === 0) return; // no flags left
      cell.flagged = !cell.flagged;
      cell.el.classList.toggle('flagged', cell.flagged);
      cell.el.textContent = cell.flagged ? 'ðŸš©' : '';
      flagsLeft += cell.flagged ? -1 : 1;
      updateStatus();
    }

    function gameOver(win) {
      status.textContent = win ? 'You cleared the field! ðŸŽ‰' : 'Boom! ðŸ’¥ Game over';
      // reveal mines
      board.flat().forEach(c => {
        if (c.mine) {
          c.el.textContent = 'ðŸ’£';
          c.el.classList.add('revealed');
        }
        c.el.removeEventListener('click', c._click);
        c.el.removeEventListener('contextmenu', c._rclick);
      });
    }

    function updateStatus() {
      status.textContent = `ðŸš© Flags left: ${flagsLeft}`;
    }

    function buildBoard() {
      const game = document.getElementById('game');
      game.style.setProperty('--rows', ROWS);
      game.style.setProperty('--cols', COLS);
      board = [];
      for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
          const el = document.createElement('div');
          el.className = 'cell';
          game.appendChild(el);

          const data = {
            el,
            r,
            c,
            mine: false,
            number: 0,
            revealed: false,
            flagged: false,
          };
          // left click
          const onClick = () => {
            if (firstClick) {
              plantMines(r, c);
              firstClick = false;
              updateStatus();
            }
            reveal(r, c);
          };
          // right click
          const onRight = (e) => {
            e.preventDefault();
            if (firstClick) return; // no flags before first click
            toggleFlag(r, c);
          };
          el.addEventListener('click', onClick);
          el.addEventListener('contextmenu', onRight);
          data._click = onClick;
          data._rclick = onRight;
          row.push(data);
        }
        board.push(row);
      }
      cellsToReveal = ROWS * COLS - MINES;
    }

    buildBoard();
  </script>
</body>
</html>
